package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"math/rand"
	"net/http"
	"strconv"
	"strings"
	"time"
)

var jobs *JobsDB

func Welcome(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Welcome!")
}

func Jobs(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Access-Control-Allow-Origin", "*")
	if r.Method == "GET" {
		ids, _ := jobs.LongListJobs()
		cnt, err := json.Marshal(ids)
		if err == nil {
			fmt.Fprintf(w, "%s\n", cnt)
		} else {
			fmt.Printf("%s\n", err)
		}
	} else {
		fmt.Fprintf(w, "Unsupported method %s", r.Method)
	}
}

func Job(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Access-Control-Allow-Origin", "*")
	toks := strings.Split(r.URL.Path, "/")
	id := toks[2]
	if r.Method == "GET" {
		if len(toks) == 3 { // ... /jobs/{id}
			j, err := jobs.GetJob(id)
			if err != nil {
				fmt.Printf("Unable to retrieve job %s: %s\n", id, err)
				http.NotFound(w, r)
			} else {
				cnt, _ := json.Marshal(j)
				fmt.Fprintf(w, "%s", cnt)
			}
		} else if len(toks) == 4 { // ... /jobs/{id}/(workloads|statistics|results)
			if toks[3] == "statistics" {
				cnt, err := jobs.GetStatistics(id)
				if err == nil {
					fmt.Fprintf(w, "%s", cnt)
				} else {
					fmt.Printf("Unable to get statistics: %s\n", err)
					http.NotFound(w, r)
				}
			} else if toks[3] == "workload" {
				cnt, err := jobs.GetWorkload(id)
				if err == nil {
					fmt.Fprintf(w, "%s", cnt)
				} else {
					fmt.Printf("Unable to get the workload: %s\n", err)
					http.NotFound(w, r)
				}
			} else if toks[3] == "results" {
				cnt, err := jobs.GetResults(id)
				if err == nil {
					fmt.Fprintf(w, "%s", cnt)
				} else {
					fmt.Printf("Unable to get the workload: %s\n", err)
					http.NotFound(w, r)
				}
			} else {
				http.NotFound(w, r)
			}
		} else {
			fmt.Printf("%s %d\n", strings.Join(toks, "|"), len(toks))
			http.NotFound(w, r)
		}
	} else if r.Method == "POST" {
		cnt, err := ioutil.ReadAll(r.Body)
		if err == nil {
			err = jobs.MakeJob(id, cnt)
			if err == nil {
				http.Redirect(w, r, "/jobs/"+id, http.StatusCreated)
			} else {
				http.NotFound(w, r)
			}
		} else {
			fmt.Fprintln(w, "Bad content")
		}
	} else if r.Method == "PUT" {
		fmt.Fprintf(w, "Update job %s", id)
	} else if r.Method == "DELETE" {
		err := jobs.DeleteJob(id)
		if err != nil {
			http.NotFound(w, r)
		}
	} else {
		http.Error(w, "Unsupported method: "+r.Method+"\n", 500)
	}

}
func main() {
	var root string
	var port int
	flag.StringVar(&root, "d", "./jobsDB", "database location")
	flag.IntVar(&port, "p", 11111, "listening port")
	flag.Parse()

	jobs, _ = NewJobsDB(root)
	go simulate()
	fmt.Printf("Bipd serves jobs in '%s' from port '%d'\n", root, port)
	http.HandleFunc("/", Welcome)
	http.HandleFunc("/jobs", Jobs)
	http.HandleFunc("/jobs/", Job)
	url := fmt.Sprintf(":%d", port)
	http.ListenAndServe(url, nil)
}

func simulate() {
	for idx := 1; idx < 200; {
		id := "job-" + strconv.Itoa(idx)
		err := jobs.MakeJob(id, []byte(id+" content"))
		if err != nil {
			fmt.Printf("Unable to create job: %s\n", err)
		}
		idx++
	}

	for idx := 1; idx < 2000; {
		op := rand.Intn(6)
		if op == 4 {
			i := rand.Intn(100) + 1
			id := "job-" + strconv.Itoa(i)
			res := make(map[string][]byte)
			res["plan"] = []byte(id + " result")
			err := jobs.CommitJob(id, []byte(makeStatistic()), res)
			fmt.Printf("%d - Job %s committed: %s\n", op, id, err)
		} else if op == 5 {
			i := rand.Intn(100) + 1
			id := "job-" + strconv.Itoa(i)
			_, err := jobs.BeginJob(id)
			fmt.Printf("%d - Job %s beginned: %s\n", op, id, err)
		}
		time.Sleep(200 * time.Millisecond)
	}

}

func makeStatistic() string {
	nodes := rand.Intn(100)
	vms := rand.Intn(100)
	managedVMs := vms / 3
	cstrs := rand.Intn(100)
	time := rand.Intn(100)
	search := rand.Intn(10000)
	backtracks := rand.Intn(10000)
	timeout := rand.Intn(2)
	doOptimize := rand.Intn(2)
	coreDuration := rand.Intn(10)
	speDuration := rand.Intn(10)
	return fmt.Sprintf("{"+
		"\"nbConstraints\":%d,"+
		"\"solvingDuration\":%d,"+
		"\"coreRPBuildDuration\":%d,"+
		"\"speRPDuration\":%d,"+
		"\"nbSearchNodes\":%d,"+
		"\"nbBacktracks\":%d,"+
		"\"isTimeout\":%d,"+
		"\"nbVMs\":%d,"+
		"\"nbNodes\":%d,"+
		"\"doOptimize\":%d,"+
		"\"timeout\":%d,"+
		"\"nbManagedVMs\":%d"+
		"}\n",
		cstrs, time, coreDuration, speDuration, search, backtracks,
		doOptimize, vms, nodes, doOptimize, timeout, managedVMs)
}
