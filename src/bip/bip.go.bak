package main

import (
	"bip"
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
)

var host string

func listJobs() {
	resp, err := http.Get("http://" + host + "/jobs")
	if err != nil || resp.StatusCode != 200 {
		fmt.Printf("Unable to list jobs:%s\n", err)
		return
	}
	cnt, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf("%s", err)
		return
	}

	var jobs []bip.Job
	err = json.Unmarshal(cnt, &jobs)
	if err != nil {
		fmt.Printf("%s", err)
		return
	}
	for i := range jobs {
		j := jobs[i]
		fmt.Printf("%s\t%d\n", j.Id, j.Status)
	}
}

func enqueueJob(id string, path string) error {
	//Read the workload from path
	cnt, err := ioutil.ReadFile(path)
	if err != nil {
		return err
	}
	resp, err := http.Post("http://"+host+"/jobs/"+id, "text/plain", bytes.NewBuffer(cnt))
	if err != nil {
		return err
	}
	if resp.StatusCode != 201 {
		return fmt.Errorf("Server reply: %s", resp.Status)
	}
	fmt.Printf("Server reply: %s", resp.Status)
	return nil
}

func getJob(id string) (bip.Job, error) {
	resp, err := http.Get("http://" + host + "/jobs/" + id)
	var j bip.Job
	if err != nil {
		fmt.Printf("Unable to get the job: %s\n", err)
		return j, err
	} else if resp.StatusCode != 200 {
		fmt.Printf("Unable to get the job '%s': %s\n", id, resp.Status)
		return j, err
	}
	cnt, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf("Unable to parse the job '%s': %s", err)
		return j, err
	}
	err = json.Unmarshal(cnt, &j)
	return j, err
}

func dequeueJob(id string) ([]byte, error) {
	fmt.Printf("Dequeuing job %s\n", id)
	return nil, nil
}

func commitJob(id string) error {
	fmt.Printf("Commit job %s\n", id)
	return nil
}

func main() {

	flag.StringVar(&host, "s", "localhost:11111", "server address")
	flag.Parse()

	cmd := flag.Arg(0)

	if len(cmd)==0 {
		fmt.Print("Supported operations: list, enqueue, dequeue, commit, get, get-status, get-workload, get-statistics, get-result\n")
		os.Exit(1)
	}
	switch cmd {
	default:
		fmt.Printf("Unsupported operation '%s'\n", cmd)
	case "list":
		listJobs()
	case "enqueue":
		err := enqueueJob(flag.Arg(1), flag.Arg(2))
		if err != nil {
			fmt.Printf("%s\n", err)
		}
	case "get":
		j, err := getJob(flag.Arg(1))
		if err != nil {
			fmt.Printf("Error: %s\n", err)
			os.Exit(1)
		}
		fmt.Printf("%s\n", j.Status)
	case "dequeue":
		dequeueJob(flag.Arg(1))
	case "commit":
		commitJob(flag.Arg(1))
	}

}
